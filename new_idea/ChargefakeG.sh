#!/bin/bash

# -*- coding: utf-8 -*-
# CHG to Gaussian Log Converter
# Author: Modified from CDFTfakeG.py by Bane
# ----------------------------------------------
# 这个脚本读取目录下的所有.chg文件，将不同类型的电荷映射为Gaussian
# 的电荷分析结果用于可视化：
# 映射偏好：Mulliken→Mulliken charges；Hirshfeld→APT charges；ADCH→Mulliken spin densities
# 超过3种电荷类型时会生成多个fake log文件

# Global variables
SCRIPT_NAME="$(basename "$0")"
TEMP_DIR="/tmp/chg_$$"

# Clean up on exit
cleanup() {
    rm -rf "$TEMP_DIR" 2>/dev/null
}
trap cleanup EXIT

# Create temp directory
mkdir -p "$TEMP_DIR"

# Print help information
print_help() {
    cat << EOF

CHG to Gaussian Log Converter
-----------------------------
Usage: 
  $SCRIPT_NAME [options]

Options:
  -o DIR      Output directory (default: current directory)
  -h          Show this help message and exit

The script automatically searches for all .chg files in the current directory.
Each .chg file should contain atomic coordinates and charges in the format:
Element X Y Z Charge

Charge type mapping preferences:
  Mulliken → Mulliken charges
  Hirshfeld → APT charges  
  ADCH → Mulliken spin densities

If more than 3 charge types are found, multiple fake log files will be generated.
Each output file contains a mapping table in the header explaining the charge assignments.

EOF
}

# Find chg files in current directory
find_chg_files() {
    local chg_files=()
    for file in *.chg; do
        if [[ -f "$file" ]]; then
            chg_files+=("$file")
        fi
    done
    echo "${#chg_files[@]}"
    printf '%s\n' "${chg_files[@]}"
}

# Get atomic number from element symbol
get_atomic_number() {
    local element="$1"
    case "$element" in
        H) echo 1 ;;
        He) echo 2 ;;
        Li) echo 3 ;;
        Be) echo 4 ;;
        B) echo 5 ;;
        C) echo 6 ;;
        N) echo 7 ;;
        O) echo 8 ;;
        F) echo 9 ;;
        Ne) echo 10 ;;
        Na) echo 11 ;;
        Mg) echo 12 ;;
        Al) echo 13 ;;
        Si) echo 14 ;;
        P) echo 15 ;;
        S) echo 16 ;;
        Cl) echo 17 ;;
        Ar) echo 18 ;;
        K) echo 19 ;;
        Ca) echo 20 ;;
        Sc) echo 21 ;;
        Ti) echo 22 ;;
        V) echo 23 ;;
        Cr) echo 24 ;;
        Mn) echo 25 ;;
        Fe) echo 26 ;;
        Co) echo 27 ;;
        Ni) echo 28 ;;
        Cu) echo 29 ;;
        Zn) echo 30 ;;
        Ga) echo 31 ;;
        Ge) echo 32 ;;
        As) echo 33 ;;
        Se) echo 34 ;;
        Br) echo 35 ;;
        Kr) echo 36 ;;
        Rb) echo 37 ;;
        Sr) echo 38 ;;
        Y) echo 39 ;;
        Zr) echo 40 ;;
        Nb) echo 41 ;;
        Mo) echo 42 ;;
        Tc) echo 43 ;;
        Ru) echo 44 ;;
        Rh) echo 45 ;;
        Pd) echo 46 ;;
        Ag) echo 47 ;;
        Cd) echo 48 ;;
        In) echo 49 ;;
        Sn) echo 50 ;;
        Sb) echo 51 ;;
        Te) echo 52 ;;
        I) echo 53 ;;
        Xe) echo 54 ;;
        *) echo 1 ;;  # Default to H
    esac
}

# Parse CHG file
parse_chg_file() {
    local chg_file="$1"
    local output_file="$2"
    
    if [[ ! -f "$chg_file" ]]; then
        echo "Error: CHG file '$chg_file' not found" >&2
        return 1
    fi
    
    # Parse coordinates and charges, skip empty lines and comments
    awk 'NF >= 5 && $1 !~ /^#/ && $1 != "" {
        printf "%s %.6f %.6f %.6f %.6f\n", $1, $2, $3, $4, $5
    }' "$chg_file" > "$output_file"
    
    local num_atoms=$(wc -l < "$output_file")
    echo "Found $num_atoms atoms in CHG file: $chg_file" >&2
    
    if [[ $num_atoms -eq 0 ]]; then
        echo "Error: No valid atoms found in CHG file: $chg_file" >&2
        return 1
    fi
    
    return 0
}

# Get charge type from filename
get_charge_type() {
    local filename="$1"
    local basename="${filename%.chg}"
    echo "$basename"
}

# Determine mapping preference for charge type
get_mapping_preference() {
    local charge_type="$1"
    case "${charge_type,,}" in  # Convert to lowercase for comparison
        *mulliken*) echo 1 ;;    # Mulliken charges
        *hirshfeld*) echo 2 ;;   # APT charges
        *adch*) echo 3 ;;        # Mulliken spin densities
        *) echo 4 ;;             # Other types
    esac
}

# Get mapping name for display
get_mapping_name() {
    local position="$1"
    case "$position" in
        1) echo "Mulliken charges" ;;
        2) echo "APT charges" ;;
        3) echo "Mulliken spin densities" ;;
        *) echo "Other charges" ;;
    esac
}

# Write Gaussian log header with mapping information
write_gaussian_log_header() {
    local mulliken_charge="$1"
    local apt_charge="$2"
    local spin_charge="$3"
    
    cat << 'EOF'
 ! This file was generated by ChargefakeG.sh
 !
 ! CHARGE TYPE MAPPING TABLE:
 ! ========================================
EOF
    
    printf " ! Mulliken charges        ← %s\n" "${mulliken_charge:-None}"
    printf " ! APT charges             ← %s\n" "${apt_charge:-None}"
    printf " ! Mulliken spin densities ← %s\n" "${spin_charge:-None}"
    
    cat << 'EOF'
 ! ========================================
 !
 ! Use this file with visualization software (e.g., GaussView, ChemCraft)
 ! to visualize charge distributions claculated by Multiwfn.
 !
 
 0 basis functions
 0 alpha electrons
 0 beta electrons
GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad
EOF
}

# Write Gaussian log geometry
write_gaussian_log_geometry() {
    local coords_file="$1"
    local compound_number="${2:-1}"
    
    echo "GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad"
    echo " "
    echo "                         Standard orientation:"
    echo " ---------------------------------------------------------------------"
    echo " Center     Atomic      Atomic             Coordinates (Angstroms)"
    echo " Number     Number       Type             X           Y           Z"
    echo " ---------------------------------------------------------------------"
    
    # Generate geometry block
    local i=1
    while IFS= read -r line; do
        local element=$(echo "$line" | awk '{print $1}')
        local x=$(echo "$line" | awk '{print $2}')
        local y=$(echo "$line" | awk '{print $3}')
        local z=$(echo "$line" | awk '{print $4}')
        local atomic_num=$(get_atomic_number "$element")
        
        printf "      %-6d     %-6d        0        %10.6f    %10.6f    %10.6f\n" "$i" "$atomic_num" "$x" "$y" "$z"
        ((i++))
    done < "$coords_file"
    
    echo " ---------------------------------------------------------------------"
    echo " "
    echo " SCF Done:      -100.000000000"
    echo " "
    echo " GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad"
    echo " Step number   $compound_number"
    echo "         Item               Value     Threshold  Converged?"
    echo " Maximum Force            1.000000     1.000000     NO"
    echo " RMS     Force            1.000000     1.000000     NO"
    echo " Maximum Displacement     1.000000     1.000000     NO"
    echo " RMS     Displacement     1.000000     1.000000     NO"
}

# Write charges section
write_charges_section() {
    local coords_file="$1"
    local charge_file1="$2"
    local charge_file2="$3" 
    local charge_file3="$4"
    
    echo "GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad"
    echo " "
    echo "          Condensed to atoms (all electrons):"
    echo " Mulliken charges and spin densities:"
    echo "               1          2"
    
    # Write Mulliken charges and spin densities
    local i=1
    while IFS= read -r coords_line; do
        local element=$(echo "$coords_line" | awk '{print $1}')
        local charge1=0.0
        local charge2=0.0
        
        # Get charge from first file (Mulliken charges)
        if [[ -f "$charge_file1" ]]; then
            local charge_line1=$(awk -v idx="$i" 'NR == idx {print $5}' "$charge_file1")
            [[ -n "$charge_line1" ]] && charge1="$charge_line1"
        fi
        
        # Get charge from third file (Mulliken spin densities)
        if [[ -f "$charge_file3" ]]; then
            local charge_line3=$(awk -v idx="$i" 'NR == idx {print $5}' "$charge_file3")
            [[ -n "$charge_line3" ]] && charge2="$charge_line3"
        fi
        
        printf "     %-2d  %-2s   %8.6f  %8.6f\n" "$i" "$element" "$charge1" "$charge2"
        ((i++))
    done < "$coords_file"
    
    # Calculate sums
    local sum1=0
    local sum2=0
    if [[ -f "$charge_file1" ]]; then
        sum1=$(awk '{sum += $5} END {print sum}' "$charge_file1")
    fi
    if [[ -f "$charge_file3" ]]; then
        sum2=$(awk '{sum += $5} END {print sum}' "$charge_file3")
    fi
    
    printf "\n Sum of Mulliken charges =  %8.5f   %8.5f\n" "$sum1" "$sum2"
    
    # APT charges section
    echo ""
    echo ""
    echo " APT charges:"
    echo "               1"
    
    # Write APT charges
    i=1
    while IFS= read -r coords_line; do
        local element=$(echo "$coords_line" | awk '{print $1}')
        local apt_charge=0.0
        
        # Get charge from second file (APT charges)
        if [[ -f "$charge_file2" ]]; then
            local charge_line2=$(awk -v idx="$i" 'NR == idx {print $5}' "$charge_file2")
            [[ -n "$charge_line2" ]] && apt_charge="$charge_line2"
        fi
        
        printf "     %-2d  %-2s    %8.6f\n" "$i" "$element" "$apt_charge"
        ((i++))
    done < "$coords_file"
    
    # Calculate APT sum
    local apt_sum=0
    if [[ -f "$charge_file2" ]]; then
        apt_sum=$(awk '{sum += $5} END {print sum}' "$charge_file2")
    fi
    printf " Sum of APT charges =  %8.5f\n" "$apt_sum"
}

# Write Gaussian log footer
write_gaussian_log_footer() {
    echo ""
    echo " Normal termination of Gaussian"
}

# Create fake Gaussian log file
create_fake_gaussian_log() {
    local coords_file="$1"
    local charge_file1="$2"
    local charge_file2="$3"
    local charge_file3="$4"
    local output_file="$5"
    local mulliken_charge="$6"
    local apt_charge="$7"
    local spin_charge="$8"
    
    echo "Writing Gaussian log file: $output_file" >&2
    
    {
        write_gaussian_log_header "$mulliken_charge" "$apt_charge" "$spin_charge"
        echo
        write_gaussian_log_geometry "$coords_file"
        echo
        write_charges_section "$coords_file" "$charge_file1" "$charge_file2" "$charge_file3"
        write_gaussian_log_footer
    } > "$output_file"
    
    echo "Fake Gaussian log file created: $output_file" >&2
    echo "Mapping table included in file header" >&2
}

# Create mapping table (now creates a summary file as well)
create_mapping_table() {
    local output_file="$1"
    shift
    local mappings=("$@")
    
    echo "Creating summary mapping table: $output_file" >&2
    
    {
        echo "==============================================="
        echo "CHG to Gaussian Log Mapping Summary"
        echo "==============================================="
        echo "Generated at: $(date)"
        echo ""
        echo "Note: Each .log file also contains its mapping"
        echo "table in the file header for easy reference."
        echo ""
        
        local log_num=1
        local i=0
        while [[ $i -lt ${#mappings[@]} ]]; do
            local log_file="${mappings[$i]}"
            local mul_charge="${mappings[$((i+1))]}"
            local apt_charge="${mappings[$((i+2))]}"
            local spin_charge="${mappings[$((i+3))]}"
            
            echo "Log File: $log_file"
            echo "  Mulliken charges        ← ${mul_charge:-None}"
            echo "  APT charges            ← ${apt_charge:-None}"
            echo "  Mulliken spin densities ← ${spin_charge:-None}"
            echo ""
            
            ((i+=4))
            ((log_num++))
        done
        
        echo "==============================================="
        echo "Mapping Preferences:"
        echo "  Mulliken    → Mulliken charges"
        echo "  Hirshfeld   → APT charges"
        echo "  ADCH        → Mulliken spin densities"
        echo "  Others      → Next available position"
        echo "==============================================="
    } > "$output_file"
}

# Main processing function
process_chg_files() {
    local output_dir="$1"
    local chg_info
    chg_info=($(find_chg_files))
    local num_files="${chg_info[0]}"
    
    if [[ $num_files -eq 0 ]]; then
        echo "Error: No .chg files found in current directory" >&2
        return 1
    fi
    
    echo "Found $num_files CHG files:"
    local chg_files=("${chg_info[@]:1}")
    printf "  %s\n" "${chg_files[@]}"
    echo ""
    
    # Parse all CHG files
    declare -A parsed_files
    declare -A charge_types
    local coords_file=""
    
    for chg_file in "${chg_files[@]}"; do
        local parsed_file="$TEMP_DIR/$(basename "$chg_file" .chg).parsed"
        if parse_chg_file "$chg_file" "$parsed_file"; then
            local charge_type=$(get_charge_type "$chg_file")
            parsed_files["$charge_type"]="$parsed_file"
            charge_types["$charge_type"]="$chg_file"
            
            # Use first file for coordinates (assuming all have same structure)
            if [[ -z "$coords_file" ]]; then
                coords_file="$parsed_file"
            fi
        fi
    done
    
    if [[ -z "$coords_file" ]]; then
        echo "Error: No valid CHG files could be parsed" >&2
        return 1
    fi
    
    # Sort charge types by preference
    local sorted_types=()
    local remaining_types=()
    
    # First pass: preferred types
    for charge_type in "${!parsed_files[@]}"; do
        local pref=$(get_mapping_preference "$charge_type")
        case "$pref" in
            1|2|3) sorted_types+=("$charge_type") ;;
            *) remaining_types+=("$charge_type") ;;
        esac
    done
    
    # Sort preferred types by preference value
    IFS=$'\n' sorted_types=($(printf '%s\n' "${sorted_types[@]}" | sort -k1,1))
    
    # Add remaining types
    sorted_types+=("${remaining_types[@]}")
    
    # Generate fake log files (3 charge types per file)
    local mappings=()
    local log_count=1
    local type_count=0
    local current_charges=("" "" "")
    local current_files=("" "" "")
    
    for charge_type in "${sorted_types[@]}"; do
        local pref=$(get_mapping_preference "$charge_type")
        local position
        
        # Determine position in current log
        if [[ $pref -le 3 ]] && [[ -z "${current_charges[$((pref-1))]}" ]]; then
            position=$((pref-1))
        else
            # Find first available position
            for ((i=0; i<3; i++)); do
                if [[ -z "${current_charges[$i]}" ]]; then
                    position=$i
                    break
                fi
            done
        fi
        
        # If no position available, start new log
        if [[ -z "$position" ]]; then
            # Generate current log
            local log_file="$output_dir/charges_fakeG_${log_count}.log"
            create_fake_gaussian_log "$coords_file" "${current_files[0]}" "${current_files[1]}" "${current_files[2]}" "$log_file" "${current_charges[0]}" "${current_charges[1]}" "${current_charges[2]}"
            
            # Store mapping info
            mappings+=("charges_fakeG_${log_count}.log" "${current_charges[0]}" "${current_charges[1]}" "${current_charges[2]}")
            
            # Reset for new log
            ((log_count++))
            current_charges=("" "" "")
            current_files=("" "" "")
            
            # Set position for new log
            local new_pref=$(get_mapping_preference "$charge_type")
            if [[ $new_pref -le 3 ]]; then
                position=$((new_pref-1))
            else
                position=0
            fi
        fi
        
        # Assign to position
        current_charges[$position]="$charge_type"
        current_files[$position]="${parsed_files[$charge_type]}"
        ((type_count++))
    done
    
    # Generate final log file
    if [[ -n "${current_charges[0]}" ]] || [[ -n "${current_charges[1]}" ]] || [[ -n "${current_charges[2]}" ]]; then
        local log_file="$output_dir/charges_fakeG_${log_count}.log"
        create_fake_gaussian_log "$coords_file" "${current_files[0]}" "${current_files[1]}" "${current_files[2]}" "$log_file" "${current_charges[0]}" "${current_charges[1]}" "${current_charges[2]}"
        mappings+=("charges_fakeG_${log_count}.log" "${current_charges[0]}" "${current_charges[1]}" "${current_charges[2]}")
    fi
    
    # Create mapping table summary
    create_mapping_table "$output_dir/mapping_table.txt" "${mappings[@]}"
    
    echo ""
    echo "✓ Processing completed successfully!"
    echo "✓ Generated $log_count fake Gaussian log file(s)"
    echo "✓ Each .log file contains mapping table in header"
    echo "✓ Created summary mapping table: $output_dir/mapping_table.txt"
    mkdir -p "../Results/Charge_$(basename "$output_dir")"
    mv charges_fakeG_* ../Results/Charge_$(basename "$output_dir")
    return 0
}

# Main function
main() {
    local output_dir="."
    
    # Parse command line arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                print_help
                exit 0
                ;;
            -o)
                output_dir="$2"
                if [[ -z "$output_dir" ]]; then
                    echo "Error: -o option requires a directory argument" >&2
                    exit 1
                fi
                shift 2
                ;;
            -*)
                echo "Unknown option: $1" >&2
                print_help
                exit 1
                ;;
            *)
                echo "Error: Unexpected argument: $1" >&2
                print_help
                exit 1
                ;;
        esac
    done
    
    # Create output directory if it doesn't exist
    if [[ ! -d "$output_dir" ]]; then
        mkdir -p "$output_dir" || {
            echo "Error: Cannot create output directory: $output_dir" >&2
            exit 1
        }
    fi
    
    # Process all CHG files
    echo "CHG to Gaussian Log Converter"
    echo "=============================="
    echo "Output directory: $output_dir"
    echo ""
    
    if ! process_chg_files "$output_dir"; then
        exit 1
    fi
}

# Run main function with all arguments
main "$@"