#include <iostream>
#include <fstream>
#include <sstream>
#include <string>
#include <map>
#include <vector>
#include <iomanip>
#include <algorithm>
#include <cstdlib>

#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#include <limits.h>
#endif

using namespace std;

// 获取可执行文件所在目录
string getExeDirectory() {
#ifdef _WIN32
    char path[MAX_PATH];
    GetModuleFileNameA(NULL, path, MAX_PATH);
    string exePath(path);
    size_t pos = exePath.find_last_of("\\/");
    return exePath.substr(0, pos);
#else
    char path[PATH_MAX];
    ssize_t count = readlink("/proc/self/exe", path, PATH_MAX);
    if (count != -1) {
        path[count] = '\0';
        string exePath(path);
        size_t pos = exePath.find_last_of('/');
        return exePath.substr(0, pos);
    }
    return ".";
#endif
}

// 转换 CHG 到 PQR
bool convertChgToPqr(const string& chgFile, const string& pqrFile, const string& vdwRadiiFile) {
    map<string, double> vdwRadii;
    ifstream radiiFile(vdwRadiiFile);
    if (!radiiFile.is_open()) return false;
    
    string element;
    double radius;
    while (radiiFile >> element >> radius) {
        transform(element.begin(), element.end(), element.begin(), ::toupper);
        vdwRadii[element] = radius;
    }
    radiiFile.close();
    
    ifstream chgIn(chgFile);
    if (!chgIn.is_open()) return false;
    
    int atomCount = 0;
    string line;
    vector<string> lines;
    
    while (getline(chgIn, line)) {
        if (!line.empty()) {
            lines.push_back(line);
            atomCount++;
        }
    }
    chgIn.close();
    
    ofstream pqrOut(pqrFile);
    if (!pqrOut.is_open()) return false;
    
    pqrOut << "REMARK   Generated by CHG to PQR converter, Totally " 
           << setw(8) << atomCount << " atoms" << endl;
    
    int atomIndex = 1;
    for (const string& dataLine : lines) {
        istringstream iss(dataLine);
        string elem;
        double x, y, z, charge;
        
        if (!(iss >> elem >> x >> y >> z >> charge)) continue;
        
        string elemUpper = elem;
        transform(elemUpper.begin(), elemUpper.end(), elemUpper.begin(), ::toupper);
        double vdwRadius = (vdwRadii.find(elemUpper) != vdwRadii.end()) 
                          ? vdwRadii[elemUpper] : 2.0;
        
        pqrOut << "HETATM"
               << setw(5) << atomIndex++
               << "  " << left << setw(4) << elem
               << right << "    A"
               << setw(4) << 1
               << "   "
               << setw(8) << fixed << setprecision(3) << x
               << setw(8) << fixed << setprecision(3) << y
               << setw(8) << fixed << setprecision(3) << z
               << setw(12) << fixed << setprecision(8) << charge
               << setw(9) << fixed << setprecision(4) << vdwRadius
               << " " << elem
               << endl;
    }
    
    pqrOut << "END" << endl;
    pqrOut.close();
    
    return true;
}

int main(int argc, char* argv[]) {
    if (argc < 2) return 1;
    
    string chgFile = argv[1];
    string exeDir = getExeDirectory();
    
    // 自动在可执行文件目录查找配置文件
#ifdef _WIN32
    string vdwRadiiFile = exeDir + "\\vdw_radii.dat";
    string tclScript = exeDir + "\\visualize.tcl";
#else
    string vdwRadiiFile = exeDir + "/vdw_radii.dat";
    string tclScript = exeDir + "/visualize.tcl";
#endif
    
    // 生成 PQR 文件名
    string pqrFile = chgFile;
    size_t pos = pqrFile.rfind(".chg");
    if (pos != string::npos) {
        pqrFile.replace(pos, 4, ".pqr");
    } else {
        pqrFile += ".pqr";
    }
    
    // 转换
    if (!convertChgToPqr(chgFile, pqrFile, vdwRadiiFile)) {
        return 1;
    }
    
    // 调用 VMD（静默启动）
    string command = "vmd -e \"" + tclScript + "\" -args \"" + pqrFile + "\"";
    system(command.c_str());
    
    return 0;
}
