// x86_64-w64-mingw32-g++ cp2k2xyz.cpp -o cp2k2xyz.exe -luser32 -lkernel32 -static-libgcc -static-libstdc++ -std=c++17 -s -O2 -mwindows

#include <windows.h>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <vector>
#include <algorithm>
#include <iomanip>

#pragma comment(lib, "user32.lib")
#pragma comment(lib, "kernel32.lib")

// 晶胞向量结构
struct CellVector {
    std::string label;  // A, B, C
    double x, y, z;
};

// 原子坐标结构
struct AtomCoord {
    std::string symbol;
    double x, y, z;
};

// 读取剪切板文本
std::string readClipboardText() {
    if (!OpenClipboard(nullptr)) {
        return "";
    }

    HANDLE hData = GetClipboardData(CF_TEXT);
    if (hData == nullptr) {
        CloseClipboard();
        return "";
    }

    char* pszText = static_cast<char*>(GlobalLock(hData));
    if (pszText == nullptr) {
        CloseClipboard();
        return "";
    }

    std::string text(pszText);
    GlobalUnlock(hData);
    CloseClipboard();

    return text;
}

// 移除注释（#后的内容）
std::string removeComments(const std::string& content) {
    std::string result;
    std::istringstream iss(content);
    std::string line;

    while (std::getline(iss, line)) {
        size_t commentPos = line.find('#');
        if (commentPos != std::string::npos) {
            line = line.substr(0, commentPos);
        }
        // 移除行尾空白
        line.erase(line.find_last_not_of(" \t\r\n") + 1);
        if (!line.empty()) {
            result += line + "\n";
        }
    }

    return result;
}

// 解析晶胞参数
std::vector<CellVector> parseCellSection(const std::string& content) {
    std::vector<CellVector> cellVectors;
    std::istringstream iss(content);
    std::string line;
    bool inCellSection = false;
    bool isPeriodicXYZ = false;

    while (std::getline(iss, line)) {
        // 移除行首尾空白
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t") + 1);

        if (line.empty()) continue;

        // 检查CELL section开始
        if (line == "&CELL") {
            inCellSection = true;
            continue;
        }

        // 检查CELL section结束
        if (line == "&END CELL" || line == "&END") {
            inCellSection = false;
            continue;
        }

        if (inCellSection) {
            // 检查PERIODIC
            if (line.find("PERIODIC") == 0) {
                std::istringstream lineStream(line);
                std::string token;
                lineStream >> token; // PERIODIC
                lineStream >> token; // 方向
                if (token == "XYZ") {
                    isPeriodicXYZ = true;
                }
                continue;
            }

            // 解析晶胞向量 (A, B, C)
            if (line.length() >= 1 && (line[0] == 'A' || line[0] == 'B' || line[0] == 'C')) {
                std::istringstream lineStream(line);
                CellVector vec;
                lineStream >> vec.label >> vec.x >> vec.y >> vec.z;

                if (lineStream) {
                    cellVectors.push_back(vec);
                }
            }
        }
    }

    // 只有在PERIODIC XYZ时才返回晶胞参数
    if (!isPeriodicXYZ) {
        cellVectors.clear();
    }

    return cellVectors;
}

// 解析坐标部分
std::vector<AtomCoord> parseCoordSection(const std::string& content) {
    std::vector<AtomCoord> atomCoords;
    std::istringstream iss(content);
    std::string line;
    bool inCoordSection = false;

    while (std::getline(iss, line)) {
        // 移除行首尾空白
        line.erase(0, line.find_first_not_of(" \t"));
        line.erase(line.find_last_not_of(" \t") + 1);

        if (line.empty()) continue;

        // 检查COORD section开始
        if (line == "&COORD") {
            inCoordSection = true;
            continue;
        }

        // 检查COORD section结束
        if (line == "&END COORD" || line == "&END") {
            inCoordSection = false;
            continue;
        }

        if (inCoordSection) {
            // 解析原子坐标
            std::istringstream lineStream(line);
            AtomCoord atom;
            lineStream >> atom.symbol >> atom.x >> atom.y >> atom.z;

            if (lineStream) {
                atomCoords.push_back(atom);
            }
        }
    }

    return atomCoords;
}

// 生成扩展XYZ格式文件内容
std::string generateXYZ(const std::vector<AtomCoord>& atoms, const std::vector<CellVector>& cellVectors) {
    std::ostringstream oss;

    // 第一行：原子数 + 晶胞参数数
    int totalLines = atoms.size() + cellVectors.size();
    oss << totalLines << "\n";

    // 第二行：注释
    oss << "generated by bane\n";

    // 原子坐标
    for (const auto& atom : atoms) {
        oss << std::left << std::setw(2) << atom.symbol
            << std::right << std::fixed << std::setprecision(8)
            << std::setw(20) << atom.x
            << std::setw(20) << atom.y
            << std::setw(20) << atom.z << "\n";
    }

    // 高斯格式晶胞参数（如果有）
    if (!cellVectors.empty()) {
        for (const auto& vec : cellVectors) {
            oss << std::left << std::setw(2) << "Tv"
                << std::right << std::fixed << std::setprecision(8)
                << std::setw(20) << vec.x
                << std::setw(20) << vec.y
                << std::setw(20) << vec.z << "\n";
        }
    }

    return oss.str();
}

// 将结果写入剪切板
bool writeToClipboard(const std::string& text) {
    if (!OpenClipboard(nullptr)) {
        return false;
    }

    EmptyClipboard();

    HGLOBAL hClipboardData = GlobalAlloc(GMEM_DDESHARE, text.size() + 1);
    if (!hClipboardData) {
        CloseClipboard();
        return false;
    }

    char* pchData = (char*)GlobalLock(hClipboardData);
    strcpy(pchData, text.c_str());
    GlobalUnlock(hClipboardData);

    SetClipboardData(CF_TEXT, hClipboardData);
    CloseClipboard();

    return true;
}

// 检查内容是否是CP2K输入格式
bool isCP2KFormat(const std::string& content) {
    return content.find("&CELL") != std::string::npos ||
           content.find("&COORD") != std::string::npos;
}

// 主函数 - 静默运行
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
    // 读取剪切板内容
    std::string clipboardContent = readClipboardText();

    if (clipboardContent.empty()) {
        return 1; // 静默失败
    }

    // 检查是否是CP2K格式
    if (!isCP2KFormat(clipboardContent)) {
        return 1; // 静默失败
    }

    // 移除注释
    std::string cleanContent = removeComments(clipboardContent);

    // 解析晶胞参数
    std::vector<CellVector> cellVectors = parseCellSection(cleanContent);

    // 解析原子坐标
    std::vector<AtomCoord> atomCoords = parseCoordSection(cleanContent);

    // 检查是否有有效的坐标数据
    if (atomCoords.empty()) {
        return 1; // 静默失败
    }

    // 生成扩展XYZ格式内容
    std::string xyzContent = generateXYZ(atomCoords, cellVectors);

    // 写入剪切板
    if (writeToClipboard(xyzContent)) {
        return 0; // 成功
    } else {
        return 1; // 静默失败
    }
}
