# -*- coding: utf-8 -*-

"""
SMILES to Gaussian Log Converter
--------------------------------
This script converts SMILES strings from a text file or directly from terminal input to 3D structures,
optimizes them using MMFF94 for 4000 steps, and writes them to a single Gaussian log file with multiple frames.

The script supports three input methods:
1. Input file with one SMILES string per line
2. Input file with multiple SMILES strings separated by periods (ChemDraw format)
3. Direct terminal input with SMILES strings (either format)

Requirements:
- openbabel (with Python bindings)
- numpy
"""

import os
import sys
import numpy as np
from openbabel import openbabel as ob
from openbabel import pybel
from rdkit import Chem
from rdkit.Chem import AllChem
import copy

print(f"BABEL_DATADIR: {os.environ.get('BABEL_DATADIR', '未设置')}") # 使用时必须激活conda环境，不然openbabel会读环境变量里的那个BABEL_DATADIR

# Global variable for optimization steps
OPT_STEPS = 4000

def smiles_to_3d(smiles):
    """Convert a SMILES string to a 3D structure using RDKit ETKDG and MMFF94 optimization."""
    # 用RDKit读入分子
    mol = Chem.MolFromSmiles(smiles)
    if mol is None:
        print(f"Error: Could not parse SMILES: {smiles}")
        return None
        
    # 添加氢原子
    mol = Chem.AddHs(mol)
    
    # 使用ETKDGv3生成3D构型
    params = AllChem.ETKDGv3()
    params.randomSeed = 42  # 固定随机种子以保证可重复性
    params.useSmallRingTorsions = True  # 使用环系统的扭转偏好
    params.useBasicKnowledge = True  # 使用基本化学知识
    params.enforceChirality = True  # 保持手性
    
    # 生成多个构象并优化
    n_confs = 10  # 生成10个构象
    confs = AllChem.EmbedMultipleConfs(mol, numConfs=n_confs, params=params)
    
    if len(confs) == 0:
        print(f"Error: Could not generate 3D conformer for: {smiles}")
        return None
    
    # MMFF94优化所有构象
    energies = []
    for conf_id in confs:
        # 初始FF优化
        props = AllChem.MMFFGetMoleculeProperties(mol)
        ff = AllChem.MMFFGetMoleculeForceField(mol, props, confId=conf_id)
        if ff is None:
            continue
        ff.Minimize(maxIts=OPT_STEPS)
        energies.append((conf_id, ff.CalcEnergy()))
    
    if not energies:
        print(f"Error: Force field optimization failed for: {smiles}")
        return None
        
    # 选择能量最低的构象
    best_conf_id = min(energies, key=lambda x: x[1])[0]
    best_conf = copy.deepcopy(mol)
    
    # 转换为OpenBabel分子对象以便输出
    conv = ob.OBConversion()
    conv.SetInAndOutFormats("mol", "mol")
    obmol = ob.OBMol()
    conv.ReadString(obmol, Chem.MolToMolBlock(best_conf, confId=best_conf_id))
    
    return pybel.Molecule(obmol)

def write_gaussian_log_header():
    """Write the header part of the Gaussian log file."""
    header = """ ! This file was generated by smiles_visualization.py
 
 0 basis functions
 0 alpha electrons
 0 beta electrons
GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad"""
    return header

def write_gaussian_log_geometry(mol, compound_number):
    """Write the geometry block of the Gaussian log file."""
    geometry = """GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad
 
                         Standard orientation:
 ---------------------------------------------------------------------
 Center     Atomic      Atomic             Coordinates (Angstroms)
 Number     Number       Type             X           Y           Z
 ---------------------------------------------------------------------
{geom}
 ---------------------------------------------------------------------
 
 SCF Done:      -100.000000000
 
 GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad
 Step number   {compound_number}
         Item               Value     Threshold  Converged?
 Maximum Force            1.000000     1.000000     NO
 RMS     Force            1.000000     1.000000     NO
 Maximum Displacement     1.000000     1.000000     NO
 RMS     Displacement     1.000000     1.000000     NO"""
    
    # Generate the geometry block
    geom_lines = []
    for i, atom in enumerate(mol.atoms):
        # Center Number, Atomic Number, Atomic Type, X, Y, Z
        x, y, z = atom.coords
        atomic_num = atom.atomicnum
        line = f"      {i+1}          {atomic_num}           0        {x:10.6f}    {y:10.6f}    {z:10.6f}"
        geom_lines.append(line)
    
    geom_block = "\n".join(geom_lines)
    
    # Format the geometry section
    geometry = geometry.format(geom=geom_block, compound_number=compound_number)
    
    return geometry

def write_gaussian_log_footer():
    """Write the footer part of the Gaussian log file."""
    footer = """GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad
 Normal termination of Gaussian"""
    return footer

def parse_smiles_from_string(content):
    """
    Parse SMILES strings from a string, supporting both:
    1. One SMILES per line format
    2. Period-separated format (from ChemDraw)
    
    Returns a list of SMILES strings.
    """
    content = content.strip()
    
    # Check if the content contains periods (ChemDraw format)
    if '.' in content and content.count('\n') < content.count('.'):
        # Split by periods and clean each SMILES string
        smiles_list = [s.strip() for s in content.split('.') if s.strip()]
        print(f"Detected period-separated SMILES format (ChemDraw format)")
    else:
        # Traditional one-per-line format
        smiles_list = [line.strip() for line in content.splitlines() if line.strip()]
        print(f"Detected one-SMILES-per-line format")
    
    return smiles_list

def parse_smiles_from_file(input_file):
    """
    Parse SMILES strings from a file, supporting both formats.
    
    Returns a list of SMILES strings.
    """
    with open(input_file, 'r') as f:
        content = f.read().strip()
    
    return parse_smiles_from_string(content)

def read_smiles_from_terminal():
    """
    Read SMILES strings from terminal input.
    User can paste multiple SMILES separated by periods or newlines.
    Input is terminated by entering a blank line.
    
    Returns a list of SMILES strings.
    """
    print("Enter/paste your SMILES strings (separated by periods or newlines).")
    print("Press Enter twice (submit a blank line) when finished:")
    
    lines = []
    while True:
        line = input()
        if not line:  # Empty line terminates input
            break
        lines.append(line)
    
    content = '\n'.join(lines)
    return parse_smiles_from_string(content)

def convert_smiles_to_gaussian_log(smiles_list, output_file):
    """Convert all SMILES strings in a list to a multi-frame Gaussian log file."""    
    print(f"Processing {len(smiles_list)} SMILES strings")
    
    # Write to output file
    with open(output_file, 'w') as f:
        # Write header
        f.write(write_gaussian_log_header())
        f.write("\n")
        
        # Process each SMILES string
        successful = 0
        for i, smiles in enumerate(smiles_list, 1):
            print(f"Processing compound {i}/{len(smiles_list)}: {smiles}")
            
            try:
                mol = smiles_to_3d(smiles)
                if mol:
                    # Write geometry block
                    geometry = write_gaussian_log_geometry(mol, i)
                    f.write(geometry)
                    f.write("\n")
                    successful += 1
                else:
                    print(f"Failed to process SMILES: {smiles}")
            except Exception as e:
                print(f"Error processing {smiles}: {str(e)}")
        
        # Write footer
        f.write(write_gaussian_log_footer())
    
    print(f"Conversion complete. Successfully processed {successful}/{len(smiles_list)} compounds.")
    print(f"Output written to {output_file}")

def process_file_input(input_file, output_file):
    """Process SMILES from an input file."""
    # Check if input file exists
    if not os.path.exists(input_file):
        print(f"Error: Input file {input_file} not found")
        sys.exit(1)
    
    # Read SMILES strings from input file
    smiles_list = parse_smiles_from_file(input_file)
    print(f"Found {len(smiles_list)} SMILES strings in {input_file}")
    
    # Convert SMILES to Gaussian log
    convert_smiles_to_gaussian_log(smiles_list, output_file)

def find_first_smi_file():
    """Find the first .smi file in the current directory."""
    for file in os.listdir('.'):
        if file.endswith('.smi'):
            return file
    return None

def print_help():
    """Print help information."""
    help_text = """
SMILES to Gaussian Log Converter
--------------------------------
Usage: python smiles_to_gaussian.py [options]

Options:
  -i FILE   Input file containing SMILES strings (one per line or period-separated)
            If not provided, first looks for .smi files, then switches to terminal input
  -s        Read SMILES directly from terminal input (interactive mode)
  -o FILE   Output Gaussian log file (default: SmilesFakeG.log)
  -c NUM    Number of MMFF94 optimization steps (default: 4000)
  -h        Show this help message and exit

Note: The script supports ChemDraw format where multiple SMILES are separated by periods.
For terminal input, paste your SMILES strings and press Enter twice to finish.
"""
    print(help_text)

def main():
    """Main function with command line argument parsing."""
    import argparse
    
    # Parse command line arguments
    parser = argparse.ArgumentParser(description="Convert SMILES to Gaussian log format",
                                     add_help=False)
    parser.add_argument("-i", dest="input_file", help="Input file containing SMILES strings")
    parser.add_argument("-s", dest="terminal_input", action="store_true",
                        help="Read SMILES directly from terminal input")
    parser.add_argument("-o", dest="output_file", default="SmilesFakeG.log", 
                       help="Output Gaussian log file (default: SmilesFakeG.log)")
    parser.add_argument("-c", dest="opt_steps", type=int, default=4000,
                       help="Number of MMFF94 optimization steps (default: 4000)")
    parser.add_argument("-h", "--help", action="store_true", help="Show help message and exit")
    
    args = parser.parse_args()
    
    # Show help and exit if requested
    if args.help:
        print_help()
        sys.exit(0)
    
    # Update the optimization steps in the smiles_to_3d function
    global OPT_STEPS
    OPT_STEPS = args.opt_steps
    
    print(f"Output file: {args.output_file}")
    print(f"Optimization steps: {OPT_STEPS}")
    
    # Check if we should read from terminal (explicitly requested)
    if args.terminal_input:
        # Read SMILES from terminal
        smiles_list = read_smiles_from_terminal()
        convert_smiles_to_gaussian_log(smiles_list, args.output_file)
    else:
        # If no input file is specified, try to find a .smi file
        if args.input_file is None:
            input_file = find_first_smi_file()
            
            # If no .smi file is found, automatically switch to terminal input
            if input_file is None:
                print("No input file specified and no .smi file found in the current directory")
                print("Automatically switching to terminal input mode...\n")
                smiles_list = read_smiles_from_terminal()
                convert_smiles_to_gaussian_log(smiles_list, args.output_file)
                return
        else:
            input_file = args.input_file
        
        print(f"Input file: {input_file}")
        process_file_input(input_file, args.output_file)

if __name__ == "__main__":
    main()
    
