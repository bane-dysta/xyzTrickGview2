import os
import sys
import subprocess
import tempfile
import time

def write_gaussian_log_header():
    """写入Gaussian log文件的头部"""
    header = """ ! This file was generated by xyz2gau.py
 
 0 basis functions
 0 alpha electrons
 0 beta electrons
GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad"""
    return header

def write_gaussian_log_geometry(atoms, coords, frame_number):
    """写入Gaussian log文件的几何结构部分"""
    geometry = """GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad
 
                         Standard orientation:
 ---------------------------------------------------------------------
 Center     Atomic      Atomic             Coordinates (Angstroms)
 Number     Number       Type             X           Y           Z
 ---------------------------------------------------------------------
{geom}
 ---------------------------------------------------------------------
 
 SCF Done:      -100.000000000
 
 GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad
 Step number   {frame_number}
         Item               Value     Threshold  Converged?
 Maximum Force            1.000000     1.000000     NO
 RMS     Force            1.000000     1.000000     NO
 Maximum Displacement     1.000000     1.000000     NO
 RMS     Displacement     1.000000     1.000000     NO"""
    
    # 生成几何结构部分
    geom_lines = []
    for i, (symbol, (x, y, z)) in enumerate(zip(atoms, coords)):
        # 确定原子序数
        atomic_num = atomic_number(symbol)
        line = f"      {i+1}          {atomic_num}           0        {x:10.6f}    {y:10.6f}    {z:10.6f}"
        geom_lines.append(line)
    
    geom_block = "\n".join(geom_lines)
    
    # 格式化几何结构部分
    return geometry.format(geom=geom_block, frame_number=frame_number)

def write_gaussian_log_footer():
    """写入Gaussian log文件的尾部"""
    footer = """GradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGradGrad
 Normal termination of Gaussian"""
    return footer

def atomic_number(symbol):
    """返回原子符号对应的原子序数"""
    atomic_numbers = {
        'H': 1, 'He': 2, 'Li': 3, 'Be': 4, 'B': 5, 'C': 6, 'N': 7, 'O': 8, 'F': 9, 'Ne': 10,
        'Na': 11, 'Mg': 12, 'Al': 13, 'Si': 14, 'P': 15, 'S': 16, 'Cl': 17, 'Ar': 18, 'K': 19, 'Ca': 20,
        'Sc': 21, 'Ti': 22, 'V': 23, 'Cr': 24, 'Mn': 25, 'Fe': 26, 'Co': 27, 'Ni': 28, 'Cu': 29, 'Zn': 30,
        'Ga': 31, 'Ge': 32, 'As': 33, 'Se': 34, 'Br': 35, 'Kr': 36, 'Rb': 37, 'Sr': 38, 'Y': 39, 'Zr': 40,
        'Nb': 41, 'Mo': 42, 'Tc': 43, 'Ru': 44, 'Rh': 45, 'Pd': 46, 'Ag': 47, 'Cd': 48, 'In': 49, 'Sn': 50,
        'Sb': 51, 'Te': 52, 'I': 53, 'Xe': 54, 'Cs': 55, 'Ba': 56, 'La': 57, 'Ce': 58, 'Pr': 59, 'Nd': 60,
        'Pm': 61, 'Sm': 62, 'Eu': 63, 'Gd': 64, 'Tb': 65, 'Dy': 66, 'Ho': 67, 'Er': 68, 'Tm': 69, 'Yb': 70,
        'Lu': 71, 'Hf': 72, 'Ta': 73, 'W': 74, 'Re': 75, 'Os': 76, 'Ir': 77, 'Pt': 78, 'Au': 79, 'Hg': 80,
        'Tl': 81, 'Pb': 82, 'Bi': 83, 'Po': 84, 'At': 85, 'Rn': 86, 'Fr': 87, 'Ra': 88, 'Ac': 89, 'Th': 90,
        'Pa': 91, 'U': 92, 'Np': 93, 'Pu': 94, 'Am': 95, 'Cm': 96, 'Bk': 97, 'Cf': 98, 'Es': 99, 'Fm': 100,
        'Md': 101, 'No': 102, 'Lr': 103, 'Rf': 104, 'Db': 105, 'Sg': 106, 'Bh': 107, 'Hs': 108, 'Mt': 109, 'Ds': 110,
        'Rg': 111, 'Cn': 112, 'Nh': 113, 'Fl': 114, 'Mc': 115, 'Lv': 116, 'Ts': 117, 'Og': 118
    }
    # 确保首字母大写，其余小写
    symbol = symbol.strip()
    if len(symbol) > 1:
        symbol = symbol[0].upper() + symbol[1:].lower()
    else:
        symbol = symbol.upper()
    
    return atomic_numbers.get(symbol, 0)  # 如果未找到，返回0

def read_xyz_frame(lines, start_line):
    """从XYZ/TRJ文件中读取一帧结构数据"""
    try:
        num_atoms = int(lines[start_line].strip())
        comment = lines[start_line + 1].strip()
        
        atoms = []
        coords = []
        
        for i in range(start_line + 2, start_line + 2 + num_atoms):
            if i < len(lines):
                parts = lines[i].strip().split()
                if len(parts) >= 4:
                    symbol = parts[0]
                    x = float(parts[1])
                    y = float(parts[2])
                    z = float(parts[3])
                    atoms.append(symbol)
                    coords.append((x, y, z))
        
        # 返回原子列表、坐标列表、下一帧起始行和注释
        next_frame_start = start_line + num_atoms + 2
        return atoms, coords, next_frame_start, comment, num_atoms
    
    except (ValueError, IndexError) as e:
        return None, None, len(lines), "", 0

def read_multi_xyz(structure_file):
    """读取多帧XYZ/TRJ文件"""
    with open(structure_file, 'r') as f:
        lines = f.readlines()
    
    frames = []
    comments = []
    line_index = 0
    
    while line_index < len(lines):
        atoms, coords, next_frame_start, comment, num_atoms = read_xyz_frame(lines, line_index)
        if atoms and coords and num_atoms > 0:
            frames.append((atoms, coords))
            comments.append(comment)
            line_index = next_frame_start
        else:
            break
    
    return frames, comments

def structure_to_gaussian(structure_file):
    """
    将结构文件转换为Gaussian格式
    
    参数:
        structure_file: XYZ或TRJ文件的路径
    
    返回:
        临时Gaussian日志文件的路径
    """
    try:
        # 读取结构文件
        frames, comments = read_multi_xyz(structure_file)
        
        if not frames:
            show_error("无法从文件中读取有效的结构数据")
            return None
        
        # 创建临时Gaussian log文件
        fd, temp_file = tempfile.mkstemp(suffix='.log')
        os.close(fd)
        
        with open(temp_file, 'w') as f:
            # 写入头部
            f.write(write_gaussian_log_header())
            f.write("\n")
            
            # 为每一帧写入几何结构
            for i, ((atoms, coords), comment) in enumerate(zip(frames, comments), 1):
                geometry = write_gaussian_log_geometry(atoms, coords, i)
                f.write(geometry)
                f.write("\n")
            
            # 写入尾部
            f.write(write_gaussian_log_footer())
        
        return temp_file
    
    except Exception as e:
        show_error(f"转换文件时出错: {str(e)}")
        return None

def open_with_gview(gaussian_file, delete_after=True, wait_seconds=5):
    """
    使用GView打开Gaussian日志文件
    
    参数:
        gaussian_file: Gaussian日志文件的路径
        delete_after: 是否在GView加载后删除临时文件
        wait_seconds: 等待GView加载文件的时间（秒）
    
    返回:
        是否成功打开文件
    """
    try:
        # 从环境变量中获取Gaussian安装目录
        gaussian_dir = os.environ.get('GAUSS_EXEDIR')
        
        if gaussian_dir:
            gview_path = os.path.join(gaussian_dir, "gview.exe")
            if os.path.exists(gview_path):
                # 启动GView查看文件
                process = subprocess.Popen([gview_path, gaussian_file])
                
                # 如果需要删除临时文件，等待一段时间让GView加载文件，然后删除
                if delete_after:
                    # 等待指定秒数，让GView有足够时间加载文件
                    print(f"等待{wait_seconds}秒后删除临时文件...")
                    time.sleep(wait_seconds)
                    try:
                        # 尝试删除临时文件
                        os.remove(gaussian_file)
                        print(f"临时文件已删除: {gaussian_file}")
                    except Exception as e:
                        print(f"无法删除临时文件: {str(e)}")
                
                return True
            else:
                show_error(f"未找到GView可执行文件: {gview_path}")
        else:
            show_error("未找到Gaussian安装目录。请设置GAUSS_EXEDIR环境变量。")
        
        return False
    
    except Exception as e:
        show_error(f"启动GView时出错: {str(e)}")
        return False

def show_error(message):
    """显示错误消息"""
    print(message)
    
    # 仅在Windows上使用MessageBox，避免使用tkinter
    if os.name == 'nt':
        try:
            import ctypes
            ctypes.windll.user32.MessageBoxW(0, message, "结构文件转换器错误", 0x10)
        except:
            pass  # 如果失败则跳过

def is_supported_file(file_path):
    """检查文件是否是支持的格式（XYZ或TRJ）"""
    _, ext = os.path.splitext(file_path.lower())
    return ext in ['.xyz', '.trj']

def main():
    """主函数"""
    # 检查命令行参数
    if len(sys.argv) < 2:
        show_error("没有主功能哦，把xyz和trj设为默认用此程序打开即可")
        return 1
    
    structure_file = sys.argv[1]
    if not os.path.exists(structure_file):
        show_error(f"文件不存在: {structure_file}")
        return 1
    
    # 检查文件格式
    if not is_supported_file(structure_file):
        show_error(f"似乎是不支持的文件格式")
        return 1
    
    # 转换文件
    gaussian_file = structure_to_gaussian(structure_file)
    if not gaussian_file:
        return 1
    
    print(f"已成功转换文件: {gaussian_file}")
    
    # 尝试用GView打开，并在成功后删除临时文件
    success = open_with_gview(gaussian_file, delete_after=True)
    
    # 如果GView失败，尝试用系统默认程序打开
    if not success:
        try:
            os.startfile(gaussian_file)
            # 注意：在这种情况下，我们不会自动删除临时文件
        except:
            show_error("无法打开文件。")
    
    return 0

if __name__ == "__main__":
    sys.exit(main()) 